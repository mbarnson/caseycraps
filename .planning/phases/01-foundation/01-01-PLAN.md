---
phase: 01-foundation
plan: 01
type: execute
domain: macos-apps
---

<objective>
Create the core game architecture: state machine and data models.

Purpose: Establish the foundation that all game logic and UI will depend on.
Output: GameManager singleton with state machine, Die/Bet/Player models.
</objective>

<execution_context>
@~/.claude/skills/create-plans/workflows/execute-phase.md
@~/.claude/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@Casey Craps/Casey Craps/GameScene.swift
@Casey Craps/Casey Craps/AppDelegate.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GameState enum and GameManager singleton</name>
  <files>Casey Craps/Casey Craps/GameManager.swift</files>
  <action>
Create a new GameManager.swift file with:

1. GameState enum with cases:
   - .waitingForBet (initial state, player must place bet)
   - .comeOut (first roll phase - 7/11 wins, 2/3/12 loses, other sets point)
   - .point(Int) (point established - hit point wins, 7 loses)
   - .resolved(won: Bool) (roll resolved, shows result before reset)

2. GameManager class as singleton:
   - static let shared = GameManager()
   - private(set) var state: GameState = .waitingForBet
   - private(set) var pointValue: Int? (current point when in point phase)
   - func placeBet() - transitions from waitingForBet to comeOut
   - func roll(die1: Int, die2: Int) - handles state transitions based on roll
   - func reset() - returns to waitingForBet

Use @Published for state so SwiftUI/observers can react. Import Combine.
Do NOT use SwiftUI views here - this is pure game logic.
  </action>
  <verify>File compiles: xcodebuild -project "Casey Craps/Casey Craps.xcodeproj" -scheme "Casey Craps" build 2>&1 | head -20</verify>
  <done>GameManager.swift exists with GameState enum and singleton, builds without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create data models</name>
  <files>Casey Craps/Casey Craps/Models.swift</files>
  <action>
Create Models.swift with:

1. Die struct:
   - var value: Int (1-6)
   - static func roll() -> Int (random 1-6)

2. BetType enum:
   - .pass (wins on 7/11 come-out, loses on 2/3/12, then wins on point, loses on 7)
   - .dontPass (opposite of pass, 12 pushes on come-out)

3. Bet struct:
   - let type: BetType
   - var amount: Int

4. Player class:
   - var bankroll: Int (start at 1000)
   - var currentBet: Bet?
   - func placeBet(type: BetType, amount: Int) -> Bool (returns false if insufficient funds)
   - func winBet() - doubles the bet amount and adds to bankroll
   - func loseBet() - clears currentBet (money already deducted on placement)
   - func pushBet() - returns bet amount to bankroll

Keep models simple - avoid over-engineering. No persistence needed yet.
  </action>
  <verify>File compiles: xcodebuild -project "Casey Craps/Casey Craps.xcodeproj" -scheme "Casey Craps" build 2>&1 | head -20</verify>
  <done>Models.swift exists with Die, BetType, Bet, Player; builds without errors</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] xcodebuild build succeeds with no errors
- [ ] GameManager.swift contains GameState enum and singleton
- [ ] Models.swift contains Die, BetType, Bet, Player
- [ ] State transitions are logically correct for craps rules
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No compiler errors or warnings
- GameManager state machine matches simplified craps flow
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
