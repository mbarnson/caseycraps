# Phase 7 Plan 01: Variable Place Bet Amounts

## Goal
Allow players to increase and decrease place bets on individual numbers, matching real craps rules where place bets are fully controllable (unlike pass line bets).

## Context
Currently, place bets can only be placed at a fixed amount or removed entirely. Real craps allows:
- Adding to an existing place bet ("press it")
- Reducing a place bet ("take down half")
- Different amounts on different numbers

This plan implements variable place bet control with full accessibility support following Apple HIG and existing codebase patterns.

## Interaction Design

### Mouse Controls
- **Left-click** on place number: Add `selectedBetAmount` to the bet (place new or increase existing)
- **Right-click** (or **Option+click**) on place number: Decrease bet by `selectedBetAmount` (or remove if reduced to zero)

### Keyboard Controls
- **Space/Enter** on focused place number: Add to bet (same as left-click)
- **Delete/Backspace** on focused place number: Decrease bet (same as right-click)
- Arrow keys continue to navigate between place numbers

### Bet Amount Selection
- Existing bet buttons ($25, $50, $100, $500) remain visible during point phase for place bet amounts
- Selected amount applies to place bet increases/decreases

## Accessibility Requirements (Apple HIG Compliance)

### VoiceOver (Vision)
- Announce bet changes: "Increased Place 6 to $150" / "Decreased Place 6 to $50"
- Announce when bet removed: "Place 6 bet removed"
- Update accessibility label to show current amount: "Place 6, current bet $100, press to increase, option-click to decrease"
- Announce interaction hints on focus

### Hearing Accessibility
- Visual feedback for bet increases: Green pulse on chip, floating "+$X" text
- Visual feedback for bet decreases: Amber/yellow pulse on chip, floating "-$X" text
- Visual feedback for bet removal: Chip shrinks and fades out
- All feedback visible regardless of audio settings (per existing pattern)

### Color Blindness
- Use shapes/patterns in addition to color:
  - Increase: Up arrow indicator (^) with green
  - Decrease: Down arrow indicator (v) with amber
- Chip amount always displayed as text (existing)

### Reduce Motion
- Skip animations, use instant state changes (per existing pattern)
- Static display of feedback text for minimum duration

### Audio Cues
- Distinct sounds differentiate increase vs decrease:
  - Increase: Ascending two-tone "chip stack" sound (existing chip click + higher note)
  - Decrease: Descending two-tone sound (existing chip click + lower note)
  - Remove: Softer single tone

## Implementation Steps

### Step 1: Model Changes (`Models.swift`)

1. **Modify `placePlaceBet()` to support increasing existing bets:**
```swift
func placePlaceBet(number: Int, amount: Int) -> Bool {
    guard amount <= bankroll else { return false }
    guard [4, 5, 6, 8, 9, 10].contains(number) else { return false }

    // Find existing bet on this number
    if let index = placeBets.firstIndex(where: {
        if case .place(let n) = $0.type { return n == number }
        return false
    }) {
        // Increase existing bet
        bankroll -= amount
        placeBets[index].amount += amount
        return true
    }

    // Place new bet
    bankroll -= amount
    placeBets.append(Bet(type: .place(number), amount: amount))
    return true
}
```

2. **Add `decreasePlaceBet()` method:**
```swift
/// Decrease a place bet by the specified amount
/// - Parameters:
///   - number: The number to decrease bet on
///   - amount: The amount to decrease by
/// - Returns: Tuple (success, newAmount) where newAmount is the remaining bet (0 if removed)
func decreasePlaceBet(number: Int, amount: Int) -> (success: Bool, newAmount: Int) {
    guard let index = placeBets.firstIndex(where: {
        if case .place(let n) = $0.type { return n == number }
        return false
    }) else {
        return (false, 0)
    }

    let currentAmount = placeBets[index].amount
    if amount >= currentAmount {
        // Remove bet entirely
        bankroll += currentAmount
        placeBets.remove(at: index)
        return (true, 0)
    } else {
        // Reduce bet
        bankroll += amount
        placeBets[index].amount -= amount
        return (true, placeBets[index].amount)
    }
}
```

### Step 2: Sound Manager (`SoundManager.swift`)

1. **Add `playBetIncrease()` method:**
```swift
/// Play bet increase sound - ascending two-tone
func playBetIncrease() {
    guard isEnabled else { return }
    // Chip click followed by higher confirmation tone
    playChipClick()
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.06) { [weak self] in
        self?.playTone(frequency: 1200, duration: 0.06, volume: 0.25)
    }
}
```

2. **Add `playBetDecrease()` method:**
```swift
/// Play bet decrease sound - descending two-tone
func playBetDecrease() {
    guard isEnabled else { return }
    // Chip click followed by lower tone
    playChipClick()
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.06) { [weak self] in
        self?.playTone(frequency: 600, duration: 0.06, volume: 0.2)
    }
}
```

### Step 3: GameScene UI Updates (`GameScene.swift`)

1. **Update `handlePlaceBetClick()` to accept click type:**
```swift
private func handlePlaceBetClick(on number: Int, isDecrease: Bool = false) {
    guard case .point = gameManager.state else { return }

    if isDecrease {
        // Decrease existing bet
        let result = gameManager.player.decreasePlaceBet(number: number, amount: selectedBetAmount)
        if result.success {
            if result.newAmount == 0 {
                // Bet removed
                SoundManager.shared.playBetDecrease()
                removePlaceChipAnimated(from: number)
                announceBetRemoved(number: number)
            } else {
                // Bet decreased
                SoundManager.shared.playBetDecrease()
                updatePlaceChip(on: number, amount: result.newAmount, decreased: true)
                announceBetChanged(number: number, newAmount: result.newAmount, increased: false)
            }
            updateBankrollDisplay()
        }
    } else {
        // Increase or place new bet
        guard gameManager.player.bankroll >= selectedBetAmount else { return }
        guard gameManager.canPlaceBet(on: number) else { return }

        let hadExistingBet = gameManager.player.hasPlaceBet(on: number)
        if gameManager.player.placePlaceBet(number: number, amount: selectedBetAmount) {
            if hadExistingBet {
                // Increased existing bet
                SoundManager.shared.playBetIncrease()
                let newAmount = gameManager.player.getPlaceBetAmount(on: number) ?? 0
                updatePlaceChip(on: number, amount: newAmount, decreased: false)
                announceBetChanged(number: number, newAmount: newAmount, increased: true)
            } else {
                // New bet placed
                SoundManager.shared.playChipClick()
                createPlaceChip(on: number, amount: selectedBetAmount)
                announceBetPlaced(amount: selectedBetAmount, betType: "Place \(number)")
            }
            updateBankrollDisplay()
        }
    }
}
```

2. **Handle right-click in `mouseDown()`:**
```swift
// In mouseDown(with event:)
if let nodeName = node.name, nodeName.starts(with: "placeNumber") {
    if let numberString = nodeName.dropFirst("placeNumber".count).description as String?,
       let number = Int(numberString) {
        // Check for right-click or Option+click for decrease
        let isDecrease = event.type == .rightMouseDown ||
                         event.modifierFlags.contains(.option)
        handlePlaceBetClick(on: number, isDecrease: isDecrease)
    }
    return
}
```

3. **Add right-click handler:**
```swift
override func rightMouseDown(with event: NSEvent) {
    let location = event.location(in: self)
    let node = atPoint(location)

    if let nodeName = node.name, nodeName.starts(with: "placeNumber") {
        if let numberString = nodeName.dropFirst("placeNumber".count).description as String?,
           let number = Int(numberString) {
            handlePlaceBetClick(on: number, isDecrease: true)
        }
    }
}
```

4. **Update keyboard activation:**
```swift
// In activateFocusedElement()
case .point4, .point5, .point6, .point8, .point9, .point10:
    if let number = focus.pointNumber {
        handlePlaceBetClick(on: number, isDecrease: false)
    }
```

5. **Add Delete/Backspace handler in keyDown():**
```swift
case 51, 117:  // Delete, Forward Delete
    if let focus = currentFocus, focus.pointNumber != nil {
        if let number = focus.pointNumber {
            handlePlaceBetClick(on: number, isDecrease: true)
        }
    }
```

### Step 4: Visual Feedback Methods (`GameScene.swift`)

1. **Add `updatePlaceChip()` for amount changes:**
```swift
private func updatePlaceChip(on number: Int, amount: Int, decreased: Bool) {
    guard let chip = placeChips[number] as? SKShapeNode else { return }

    // Update label
    if let label = chip.children.first as? SKLabelNode {
        label.text = "$\(amount)"
    }

    // Show visual feedback
    showBetChangeFeedback(on: number, amount: decreased ? -selectedBetAmount : selectedBetAmount, decreased: decreased)
}
```

2. **Add `showBetChangeFeedback()` for hearing accessibility:**
```swift
private func showBetChangeFeedback(on number: Int, amount: Int, decreased: Bool) {
    guard let position = crapsTable?.getPointBoxPosition(number: number) else { return }

    // Colors (WCAG compliant)
    let color: SKColor = decreased ?
        SKColor(red: 1.0, green: 0.8, blue: 0.2, alpha: 1.0) :  // Amber for decrease
        SKColor(red: 0.4, green: 1.0, blue: 0.4, alpha: 1.0)    // Green for increase

    // Direction indicator for color blindness
    let indicator = decreased ? "v" : "^"
    let amountText = decreased ? "-$\(abs(amount))" : "+$\(abs(amount))"

    // Create feedback label
    let label = SKLabelNode(text: "\(indicator) \(amountText)")
    label.fontSize = 24
    label.fontName = "Arial-BoldMT"
    label.fontColor = color
    label.position = CGPoint(x: position.x, y: position.y - 50)
    label.zPosition = 200
    crapsTable?.addChild(label)

    let remove = SKAction.removeFromParent()

    if NSWorkspace.shared.accessibilityDisplayShouldReduceMotion {
        // Static display
        let wait = SKAction.wait(forDuration: 0.8)
        label.run(SKAction.sequence([wait, remove]))
    } else {
        // Animate: float in direction of change
        let moveY: CGFloat = decreased ? -40 : 40
        let move = SKAction.moveBy(x: 0, y: moveY, duration: 0.8)
        let fade = SKAction.fadeOut(withDuration: 0.8)
        label.run(SKAction.sequence([SKAction.group([move, fade]), remove]))
    }

    // Pulse the chip
    if let chip = placeChips[number] {
        pulseChip(chip, color: color)
    }
}
```

3. **Add `removePlaceChipAnimated()` for bet removal:**
```swift
private func removePlaceChipAnimated(from number: Int) {
    guard let chip = placeChips[number] else { return }

    if NSWorkspace.shared.accessibilityDisplayShouldReduceMotion {
        chip.removeFromParent()
    } else {
        let shrink = SKAction.scale(to: 0, duration: 0.2)
        let fade = SKAction.fadeOut(withDuration: 0.2)
        let remove = SKAction.removeFromParent()
        chip.run(SKAction.sequence([SKAction.group([shrink, fade]), remove]))
    }

    placeChips[number] = nil
}
```

4. **Add `pulseChip()` helper:**
```swift
private func pulseChip(_ chip: SKNode, color: SKColor) {
    guard !NSWorkspace.shared.accessibilityDisplayShouldReduceMotion else { return }

    // Create pulse overlay
    let pulse = SKShapeNode(circleOfRadius: 22)
    pulse.fillColor = .clear
    pulse.strokeColor = color
    pulse.lineWidth = 3
    pulse.position = chip.position
    pulse.zPosition = chip.zPosition + 1
    crapsTable?.addChild(pulse)

    let expand = SKAction.scale(to: 1.3, duration: 0.15)
    let contract = SKAction.scale(to: 1.0, duration: 0.15)
    let remove = SKAction.removeFromParent()
    pulse.run(SKAction.sequence([expand, contract, remove]))
}
```

### Step 5: Accessibility Announcements (`GameScene.swift`)

1. **Add `announceBetChanged()` method:**
```swift
private func announceBetChanged(number: Int, newAmount: Int, increased: Bool) {
    let action = increased ? "Increased" : "Decreased"
    let announcement = "\(action) Place \(number) to $\(newAmount)"
    NSAccessibility.post(element: self.view as Any, notification: .announcementRequested,
                        userInfo: [.announcement: announcement])
}
```

2. **Add `announceBetRemoved()` method:**
```swift
private func announceBetRemoved(number: Int) {
    let announcement = "Place \(number) bet removed"
    NSAccessibility.post(element: self.view as Any, notification: .announcementRequested,
                        userInfo: [.announcement: announcement])
}
```

3. **Update `announceFocusChange()` for place numbers:**
```swift
case .point4, .point5, .point6, .point8, .point9, .point10:
    if let number = element.pointNumber {
        if let currentBet = gameManager.player.getPlaceBetAmount(on: number) {
            announcement = "Place \(number), current bet $\(currentBet). Space to increase, Delete to decrease."
        } else {
            announcement = "Place \(number), no bet. Space to place bet."
        }
    } else {
        announcement = "Point number"
    }
```

### Step 6: Show Bet Buttons During Point Phase (`GameScene.swift`)

1. **Modify `updateBetButtonStates()` to show during point phase:**
```swift
private func updateBetButtonStates() {
    let amounts = [25, 50, 100, 500]
    let bankroll = gameManager.player.bankroll
    let isWaitingForBet = gameManager.state == .waitingForBet
    let isPointPhase: Bool
    if case .point = gameManager.state { isPointPhase = true } else { isPointPhase = false }

    let showButtons = isWaitingForBet || isPointPhase

    for (index, amount) in amounts.enumerated() {
        if index < betButtons.count, let button = betButtons[index] as? SKShapeNode {
            button.isHidden = !showButtons
            // ... rest of styling logic
        }
    }
}
```

## Verification Checklist

- [ ] Left-click on place number adds to bet
- [ ] Right-click/Option+click decreases bet
- [ ] Bet reduced to zero removes chip
- [ ] Different sounds for increase vs decrease
- [ ] Visual feedback shows +/- amount with directional indicator
- [ ] VoiceOver announces all bet changes
- [ ] Keyboard: Space increases, Delete decreases
- [ ] Reduce Motion: animations skip, static feedback shown
- [ ] Bet buttons visible during point phase
- [ ] Bankroll updates correctly on all operations

## Files to Modify

1. `Casey Craps/Casey Craps/Models.swift` - Update placePlaceBet(), add decreasePlaceBet()
2. `Casey Craps/Casey Craps/SoundManager.swift` - Add playBetIncrease(), playBetDecrease()
3. `Casey Craps/Casey Craps/GameScene.swift` - Update click handlers, add visual feedback, add accessibility

## Dependencies

- None (builds on existing Phase 6 accessibility infrastructure)
